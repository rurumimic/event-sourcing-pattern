# 이벤트 소싱 패턴

- Microsoft
  - [Event Sourcing Pattern](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/event-sourcing)
  - [Reference 3: Introducing Event Sourcing](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)?redirectedfrom=MSDN)

- 기존: 도메인에 데이터의 현재 상태만 저장
- 이벤트 소싱: 데이터를 이용한 **기록**을 **추가 전용 저장소**(append-only store)에 저장
- 추가 전용 저장소: 기록 보관소 역할
  - 이 기록으로 도메인 개체를 구체화할 수 있다.
- **장점**:
  1. 복잡했던 도메인 작업이 간단해진다.
     - 이유: 동기화 불필요. 데이터 모델 != 비즈니스 도메인
     - 결과: 확장성, 응답성 ↑
  1. 일관적인 트랜잭션 데이터: 데이터 변화 과정에 모순이 없다.
  1. 전체 감사 추적(full audit trails)과 기록이 남는다.
     - 데이터를 다시 보정할 수 있다.

## Context와 Problem

### 기존 CRUD 데이터 프로세스

1. 현재 상태 변경 요구
1. 데이터 잠금 필요
1. 트랜잭션 사용
1. 새 값으로 수정

### 기존 CRUD 제한 사항

- 성능, 응답 속도 저하, 확장성 제한: 데이터 저장소에서 직접 업데이트 작업을 수행해야 하기 때문.
- 업데이트 충돌: 많은 동시 사용자 → 단일 데이터 항목 공동 작업 → 충돌
- 기록 유실: 로그를 기록하는 추가적인 감사 메커니즘(auditing mechanism)이 없을 때

### 참고

[CRUD, only when you can afford it](https://docs.microsoft.com/ko-kr/archive/blogs/maarten_mullender/crud-only-when-you-can-afford-it-revisited)

## 해결책

1. 이벤트 생성: 애플리케이션 코드 작업
   - 데이터에 대한 변경 집합
1. 이벤트 저장: 이벤트 저장소에 기록한다
1. 이벤트 게시: 구체화된 뷰(Materialized View) 업데이트 
1. 이벤트 재생: 엔티티의 현재 상태 구체화
   - 구체화된 도메인 개체가 필요할 때 이벤트 재생이 일어난다. 
   - 요청을 처리하거나 예약된 작업을 수행하면서, 프레젠테이션 레이어가 사용하고 있는 구체화된 뷰에 저장할 수 있다.

![](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/event-sourcing-overview.png)

### 장점

- 이벤트는 불변이다. 
  - 이벤트를 처리하는 태스크를 분리할 수 있다: 백그라운드에서 작업이 가능하다.
  - 애플리케이션의 **성능과 확장성 ↑**
    - **트랜잭션 충돌이 일어나지 않는다.**
    - 이벤트를 추가 전용 작업으로 저장하기 때문이다.
- 이벤트는 단순한 개체일뿐이다.
  - 작업에 대한 설명만 기록한다.
  - 데이터 저장소를 직접 수정하지 않는다.
  - 나중에 적절한 때가 되면 처리하기 위해 기록될 뿐이다.
  - **구현과 관리가 간편해진다.**
- [개체 관계형 임피던스 불일치](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) 해결:
  - RDBMS와 애플리케이션은 구조가 다르다.
- 모니터링, 디버깅, 테스트 지원
  - 변경 내용이 기록되기 때문이다.
  - 이벤트 목록으로 기타 유용한 비즈니스 정보도 얻을 수 있다.
- 이벤트와 태스크의 분리
  - 유연성, 확장성 ↑
  - **하지만, 이벤트 소싱의 이벤트는 매우 낮은 레벨이기 때문에 이벤트를 조합할 필요도 있다.**

이벤트 소싱은 일반적으로 CQRS 패턴과 결합된다.

## 이슈와 고려 사항

참고: [데이터 일관성에 대해서](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)?redirectedfrom=MSDN)

- 시스템 일치 시점:
  1. 구체화된 뷰를 만들었을 때
  1. 데이터 프로젝션을 생성했을 때
- 요청을 처리하는 사이에 새 이벤트가 추가될 수도 있다.
- 이벤트 데이터는 업데이트 하지 않는다.
  - 업데이트 대신 변경을 위한 이벤트를 추가해야한다.
- 마이그레이션 과정 중에 지속형 이벤트 형식(format of the persisted events) 변경이 필요할 때, 이미 존재하는 이벤트를 새 버전 형식에 맞추기 어려울 것이다.
  - 모든 이벤트를 순차적으로 변경하거나, 새로운 형식을 사용하는 새 이벤트를 추가해야 한다.
  - 각 버전마다 버전 스탬프를 사용해서 이전과 새로운 이벤트 형식을 유지 관리하는 것이 좋다.
- 다중 스레드 애플리케이션과 여러 애플리케이션 인스턴스가 이벤트를 저장할 수 있다.
  - 이벤트 저장 순서는 현재 상태에 영향을 준다.
  - 모든 이벤트에 타임스탬프를 추가하여 문제를 방지한다.
  - 증분 식별자를 주석으로 추가한다.
    - 동일한 엔티티에 대한 이벤트 동시 추가할 때, 이벤트 저장소에서 기존 엔티티 식별자 및 이벤트 식별자와 일치하는 이벤트를 거부한다.
- 이벤트를 읽는 표준 방법이나 SQL 쿼리 같은 메커니즘은 없다.
  - 이벤트 식별자를 기준으로 이벤트 스트림을 추출한다.
  - 이벤트 ID는 엔티티와 매핑된다.
  - 엔티티의 현재 상태는 관련된 모든 이벤트를 해당 엔티티의 원래 상태에 대해 재생해야만 확인할 수 있다.
- 이벤트 스트림 길이는 시스템 관리 및 업데이트에 영향을 준다.
  - 스트림이 큰 경우 특정 간격(이벤트 수)으로 스냅샷을 생성한다.
  - 스냅샷 이후 발생한 이벤트를 재생해 엔티티의 현재 상태를 확인한다.
  - 마틴 파울러: [Snapshot](https://martinfowler.com/eaaDev/Snapshot.html)
  - 마이크로소프트: [Master-Subordinate Snapshot Replication](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff650012(v=pandp.10))
- 이벤트 소싱이 데이터 업데이트의 충돌 가능성을 최소화하더라도 애플리케이션이 결과적으로 일관성과 트랜잭션 부족에서 발생하는 불일치를 처리해야 한다.
  - 예를 들어, 해당 품목이 주문되는 동안 재고 감소를 나타내는 이벤트가 데이터 저장소에 도착하여 고객에게 안내하거나 이월 주문을 만들어 두 작업을 조정해야 할 수 있다.
- 이벤트 게시는 "한 번 이상"일 수 있으므로 이벤트의 소비자가 멱등(idempotent) 해야 한다.
  - 이벤트가 두 번 이상 처리되는 경우 이벤트에 설명된 업데이트를 다시 적용하면 안된다.
  - 예를 들어, 여러 소비자 인스턴스가 총 주문 수와 같은 엔티티 속성을 집계할 때, 주문 이벤트가 발생한 경우 한 인스턴스만 집계 증분에 성공해야 한다.

## 이 패턴을 사용해야 하는 경우

- 데이터의 의도, 목적, 이유를 기록하려는 경우
- 데이터 업데이트 충돌 발생을 최소화하거나 완전히 방지하는 것이 중요한 경우
- 이벤트를 기록, 추적하여 롤백, 복원하려는 경우
- 애플리케이션에 이미 이벤트 생성하는 기능이 있는 경우
- 데이터 입력, 업데이트 프로세스와 프로세스를 적용하는 태스크를 분리하는 경우
  - UI 성능 향상
  - 이벤트 분배
- 요구 사항 변경에 따라 모델, 엔티티를 변경하고 싶은 경우
- CQRS와 함께 사용 시 읽기 모델이 업데이트되는 동안 결과적 일관성 허용되는 경우
- 이벤트 스트림에서 데이터를 복원할 때 성능 영향이 허용되는 경우

## 이 패턴이 좋지 않은 경우

- 작거나 단순한 도메인
- 비즈니스 로직이 거의 없거나 전혀 없는 시스템
- 기존 CRUD 데이터 관리 메커니즘으로 잘 동작하는 비도메인 시스템
- 데이터 뷰에 대한 일관성, 실시간 업데이트가 필요한 시스템
- 감사 추적, 기록, 작업 롤백, 재생 기능이 필요 없는 시스템
- 기본 데이터에 대한 업데이트 충돌 발생이 매우 적은 시스템
  - 예를 들어, 데이터를 업데이트하지 않고 주로 추가하는 시스템

## 예제

회의 관리 시스템: 
- 사용 가능한 좌석 확인
- 회의 예약 수 추적

총 회의 예약 수 저장 방법:
1. 총 예약 수에 대한 정보 저장
   - 간단하다
   - 확장성 문제: 예약 기간 마감 전날
1. 예약 및 취소 정보를 보류된 이벤트로 이벤트 저장소에 저장. 이벤트 재생하여 사용 가능한 좌석 수 계산
   - 확장성
   - 시스템 역할:
     - 데이터 읽기
     - 데이터 추가

![](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/_images/event-sourcing-bounded-context.png)

1. 좌석 2개 예약 요청
   - 명령 처리기로 명령 전달
1. 모든 예약 정보 집계 생성 (SeatAvailability)
   - 도메인 모델에 포함
   - 최적화 고려: 스냅샷 사용. 집계 캐싱.
1. 명령 처리기가 예약 수행 메소드 호출
1. 예약된 좌석 수를 계산하는 이벤트를 기록
1. 새 이벤트 추가

## 관련 패턴 및 지침

- CQRS
- 구체화된 뷰 패턴
- 보상 트랜잭션 패턴
- 데이터 일관성 입문
- 데이터 분할 지침
